### 初识Semaphore
“信号量”，也可以称其为“信号灯”，它的存在就如同生活中的红绿灯一般，用来控制车辆的通行。在程序员眼中，线程就好比行驶的车辆，程序员就可以通过信号量去指定线程是否可以执行，并且可以指定访问临界区的线程数量；
### 信号量模型
信号量的模型很简单，有：一个计数器，一个等待队列，三个方法（init，down，up）。在该模型中，计数器与等待队列对外是透明的，只能去通过三个方法区访问。
### 三个方法详解：
> 1. init()：设置计数器的初始值（信号量是支持多个线程访问一个临界区的，所以可以通过设置计数器的初始值来控制线程访问临界资源的数量）
> 
> 2. down()：计数器减一操作；如果此时计数器的值小于0，则当前线程被阻塞，否则当前线程可以继续执行。
> 
> 3. up()：计数器加一操作；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。

**注意**：这里的三个方法均是原子操作。在Java SDK里，信号量是由java.util.concurrent.Semaphore实现的，Semaphore可以保证方其都是原子操作。并且在Java SDK并发包中，down()和up()对应的是acquire()和release()方法。

参考下面代码感受一下信号量模型：
```java
class Semaphore{
  // 计数器
  int count;
  // 等待队列
  Queue queue;
  // 初始化操作
  Semaphore(int c){
    this.count=c;
  }
  // 
  void down(){
    this.count--;
    if(this.count<0){
      // 将当前线程插入等待队列
      // 阻塞当前线程
    }
  }
  void up(){
    this.count++;
    if(this.count<=0) {
      // 移除等待队列中的某个线程 T
      // 唤醒线程 T
    }
  }
}
```
### 关于信号量的使用
#### 1. 如何互斥操作
正如开篇介绍信号量可以控制线程的执行，相当于互斥锁一样，控制单一线程对临界资源的访问。而信号量正是通过计数器来实现互斥规则的。

如下代码:

在进入临界区之前执行down()方法，退出前执行up()方法皆就可以了。在实例代码中acquire就相当于down方法，release相当于up方法；
```java
static int count;
// 初始化信号量
static final Semaphore s 
    = new Semaphore(1);
// 用信号量保证互斥    
static void addOne() {
  s.acquire();
  try {
    count+=1;
  } finally {
    s.release();
  }
}
```
**信号量具体如何实现互斥？**

比如现有两个线程 t1与t2，而我们规定在初始化计数器时将计数器设置为1，表明临界区只允许一个线程去访问。当两个线程同时访问addOne()方法时，两个线程同时执行acquire()方法，由于acquire()是一个原子操作，当t1将计数器值减为0，t2将计数器减为-1。对于t1而言，信号量的计数器值为0，满足大于等于0条件，所以t1会继续执行；对于t2而言，信号量里边的计数器为-1，小于0，按照down()操作的描述，t2会被阻塞。因此只有t1线程进入临界区执行count+=1操作。

当t1执行release()操作时，信号量里边的计数器会+1，此时为0，小于等于0，因此会将处于等待队列中的t2线程唤醒。于是t2在t1执行完临界代码之后进入到了临界区。从而保证了互斥性。
#### 2. Semaphore如何实现多个线程访问一个临界区
Semaphore有一个独特的功能，就是可以允许多个线程访问一个临界区。这里就通过“快速实现一个限流器”来说明；

**对象池**：指的是一次性创建出 N 个对象，之后所有的线程重复利用这 N 个对象，当然对象在被释放前，也是不允许其他线程使用的。

这里的限流就是指不允许多余N个线程同时进入临界区

**解决方法**：在上一个例子中我们将计数器初始化为1，表示只允许一个线程进入临界区，现在我们将计数器设置为对象池中的对象个数N，表明在同一个时刻允许N个线程可以同时进入到临界区，就可以解决限流问题了；

**思考**：信号量在在执行release()方法后如果满足唤醒其他线程条件就会去唤醒一个线程继续执行，这里为什么不能去唤醒所有线程呢？

由于信号量没有Condition概念，当阻塞线程被唤醒会直接运行，不会去检查此时的临界条件是否满足，因此信号量只允许唤醒一个阻塞线程，否则就会出现缺少临界条件检查而带来的线程安全问题。
