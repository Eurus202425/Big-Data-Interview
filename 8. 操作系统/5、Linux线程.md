###一、基础知识：线程和进程

按照教科书上的定义，进程是资源管理的最小单位，线程是程序执行的最小单位。在操作系统设计上，从进程演化出线程，最主要的目的就是更好的支持SMP以及减小（进程/线程）上下文切换开销。

无论按照怎样的分法，一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（比如cpu、内存、文件等等），而将线程分配到某个cpu上执行。一个进程当然可以拥有多个线程，此时，如果进程运行在SMP机器上，它就可以同时使用多个cpu来执行各个线程，达到最大程度的并行，以提高效率；
同时，即使是在单cpu的机器上，采用多线程模型来设计程序，正如当年采用多进程模型代替单进程模型一样，使设计更简洁、功能更完备，程序的执行效率也更高，例如采用多个线程响应多个输入，而此时多线程模型所实现的功能实际上也可以用多进程模型来实现，
而与后者相比，线程的上下文切换开销就比进程要小多了，从语义上来说，同时响应多个输入这样的功能，实际上就是共享了除cpu以外的所有资源的。

针对线程模型的两大意义，分别开发出了核心级线程和用户级线程两种线程模型，分类的标准主要是线程的调度者在核内还是在核外。前者更利于并发使用多处理器的资源，而后者则更多考虑的是上下文切换开销。
在目前的商用系统中，通常都将两者结合起来使用，既提供核心线程以满足smp系统的需要，也支持用线程库的方式在用户态实现另一套线程机制，此时一个核心线程同时成为多个用户态线程的调度者。
正如很多技术一样，"混合"通常都能带来更高的效率，但同时也带来更大的实现难度，出于"简单"的设计思路，Linux从一开始就没有实现混合模型的计划，但它在实现上采用了另一种思路的"混合"。

在线程机制的具体实现上，可以在操作系统内核上实现线程，也可以在核外实现，后者显然要求核内至少实现了进程，而前者则一般要求在核内同时也支持进程。
核心级线程模型显然要求前者的支持，而用户级线程模型则不一定基于后者实现。这种差异，正如前所述，是两种分类方式的标准不同带来的。

当核内既支持进程也支持线程时，就可以实现线程-进程的"多对多"模型，即一个进程的某个线程由核内调度，而同时它也可以作为用户级线程池的调度者，选择合适的用户级线程在其空间中运行。这就是前面提到的"混合"线程模型，既可满足多处理机系统的需要，也可以最大限度的减小调度开销。
绝大多数商业操作系统（如Digital Unix、Solaris、Irix）都采用的这种能够完全实现POSIX1003.1c标准的线程模型。在核外实现的线程又可以分为"一对一"、"多对一"两种模型，前者用一个核心进程（也许是轻量进程）对应一个线程，将线程调度等同于进程调度，交给核心完成，
而后者则完全在核外实现多线程，调度也在用户态完成。后者就是前面提到的单纯的用户级线程模型的实现方式，显然，这种核外的线程调度器实际上只需要完成线程运行栈的切换，调度开销非常小，
但同时因为核心信号（无论是同步的还是异步的）都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统，而这个需求正变得越来越大，因此，在现实中，纯用户级线程的实现，除算法研究目的以外，几乎已经消失了。

Linux内核只提供了轻量进程的支持，限制了更高效的线程模型的实现，但Linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前最流行的线程机制LinuxThreads所采用的就是线程-进程"一对一"模型，调度交给核心，而在用户级实现一个包括信号处理在内的线程管理机制。
Linux-LinuxThreads的运行机制正是本文的描述重点。

###二、Linux线程的调度机制

在Linux中，线程是由进程来实现，线程就是轻量级进程（ lightweight process ），因此在Linux中，线程的调度是按照进程的调度方式来进行调度的。Linux这样实现的线程的好处的之一是：线程调度直接使用进程调度就可以了，没必要再搞一个进程内的线程调度器。
　　
在Linux中，调度器是基于线程的调度策略（scheduling policy）和静态调度优先级（static scheduling priority）来决定那个线程来运行。
　
对于下面三种调度策略SCHED_OTHER, SCHED_IDLE, SCHED_BATCH，其调度优先级sched_priority是不起作用的，即可以看成其调度优先级为0；
调度策略SCHED_FIFO和SCHED_RR是实时策略，他们的调度值范围是1到99，数值越大优先级越高，另外实时调度策略的线程总是比前面三种通常的调度策略优先级更高。
通常，调度器会为每个可能的调度优先级（sched_priority value）维护一个可运行的线程列表，并且是以最高静态优先级列表头部的线程作为下次调度的线程。所有的调度都是抢占式的：如果一个具有更高静态优先级的线程转换为可以运行了，那么当前运行的线程会被强制进入其等待的队列中。下面介绍几种常见的调度策略：

SCHED_OTHER：该策略是是默认的Linux分时调度（time-sharing scheduling）策略，它是Linux线程默认的调度策略。SCHED_OTHER策略的静态优先级总是为0，对于该策略列表上的线程，调度器是基于动态优先级（dynamic priority）来调度的，
动态优先级是跟nice中相关(nice值可以由接口nice, setpriority,sched_setattr来设置)，该值会随着线程的运行时间而动态改变，以确保所有具有SCHED_OTHER策略的线程公平运行。在Linux上，nice值的范围是-20到+19，默认值为0；
nice值越大则优先级越低，相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的处理器时间。使用命令ps -el查看系统的进程列表，其中NI列就是进程对应的nice值；使用top命令，看到的NI列也是nice值。运行命令的时候可用nice –n xx cmd来调整cmd任务的nice值，xx的范围是-20~19之间。

SCHED_FIFO：先入先出调度策略（First in-first out scheduling）。该策略简单的说就是一旦线程占用cpu则一直运行，一直运行直到有更高优先级任务到达或自己放弃。

SCHED_RR：时间片轮转调度(Round-robin scheduling)。该策略是SCHED_FIFO基础上改进来的，他给每个线程增加了一个时间片限制，当时间片用完后，系统将把该线程置于队列末尾。放在队列尾保证了所有具有相同优先级的RR任务的调度公平。使用top命令，如果PR列的值为RT，则说明该进程采用的是实时策略，即调度策略是SCHED_FIFO或者为SCHED_RR，而对于非实时调度策略（比如SCHED_OTHER）的进程，该列的值是NI+20，以供Linux内核使用。我们可以通过命令：

　
+ 调度优先级策略：
实时调度策略大于分时调度策略；
当实时进程/线程准备就绪后，如果当前CPU正在运行分时进程/线程，则实时进程/线程立即抢占分时进程/线程。
同样都是实时调度策略，优先级高的先执行。
　　
所有任务都采用Linux分时调度策略时：
　　1. 创建任务指定采用分时调度策略，并指定优先级nice值(-20~19)。
　　2. 将根据每个任务的nice值确定在CPU上的执行时间(counter)。
　　3. 如果没有等待资源，则将该任务加入到就绪队列中。
　　4. 调度程序遍历就绪队列中的任务，通过对每个任务动态优先级的计算(counter+20-nice)结果，选择计算结果最大的一个去运行，当这个时间片用完后(counter减至0)或者主动放弃CPU时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃CPU)中。
　　5. 此时调度程序重复上面计算过程，转到第4步。
　　6. 当调度程序发现所有就绪任务计算所得的权值都为不大于0时，重复第2步。
　　
所有任务都采用FIFO时：
　　1. 创建进程时指定采用FIFO，并设置实时优先级rt_priority(1-99)。
　　2. 如果没有等待资源，则将该任务加入到就绪队列中。
　　3. 调度程序遍历就绪队列，根据实时优先级计算调度权值(1000+rt_priority),选择权值最高的任务使用cpu，该FIFO任务将一直占有CPU直到有优先级更高的任务就绪(即使优先级相同也不行)或者主动放弃(等待资源)。
　　4. 调度程序发现有优先级更高的任务到达(高优先级任务可能被中断或定时器任务唤醒，再或被当前运行的任务唤醒，等等)，则调度程序立即在当前任务堆栈中保存当前CPU寄存器的所有数据，重新从高优先级任务的堆栈中加载寄存器数据到CPU，此时高优先级的任务开始运行。重复第3步。
　　5. 如果当前任务因等待资源而主动放弃CPU使用权，则该任务将从就绪队列中删除，加入等待队列，此时重复第3步。
　　
所有任务都采用RR调度策略时：
　　1. 创建任务时指定调度参数为RR，并设置任务的实时优先级和nice值(nice值将会转换为该任务的时间片的长度)。
　　2. 如果没有等待资源，则将该任务加入到就绪队列中。
　　3. 调度程序遍历就绪队列，根据实时优先级计算调度权值(1000+rt_priority),选择权值最高的任务使用CPU。
　　4. 如果就绪队列中的RR任务时间片为0，则会根据nice值设置该任务的时间片，同时将该任务放入就绪队列的末尾。重复步骤3。
　　5. 当前任务由于等待资源而主动退出CPU，则其加入等待队列中。重复步骤3。
